# strategy.py

import datetime
import numpy as np
import pandas as pd
import Queue

from abc import ABCMeta, abstractmethod

from event import SignalEvent

class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars 
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def generate_positions(self):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")

#####################
###Sample strategy###
#####################

class BuyAndHoldStrategy(Strategy):
    """
    This is an extremely simple strategy that goes LONG all of the 
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, bars, events):
        """
        Initialises the buy and hold strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbols
        self.events = events

        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_positions()

    def _calculate_initial_positions(self):
        """
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def generate_positions(self, event):
        """
        For "Buy and Hold" we generate a single signal per symbol
        and then no additional signals. This means we are 
        constantly long the market from the date of strategy
        initialisation.

        Parameters
        event - A MarketEvent object. 
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=1)
                if bars is not None and bars != []:
                    if self.bought[s] == False:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
                        self.events.put(signal)
                        self.bought[s] = True


#########################################################

class MeanReversion(Strategy):

    def __init__(self, datahandler, events, symbols):
        
        self.datahandler = datahandler
        self.events = events
        self.symbols = symbols

        self.threshold = 0.05 #threshold for z-score
        self.stock1 = 'AMRI'
        self.stock2 = 'MASI'
        self.stock3 = 'INCR'

        self.positions = self._generate_initial_positions

    def _generate_initial_positions(self):
        return pd.Series(np.zeros(len(self.symbols)), index=self.symbols)

    def generate_positions(self, event):
        
        if event.type == 'MARKET':
            
            # Getting data
            price_data = {}
            lookback_period = 1

            for symbol in self.symbols:
                price_data[symbol] = self.datahandler.get_latest_price_data(symbol, N=lookback_period)

            # Strategy code goes here

class SimpleMeanReversionGroupTrading_AMRI_MASI_INCR(Strategy):

    def __init__(self, events, datahandler, symbols):

        self.datahandler = datahandler
        self.events = events
        self.symbols = symbols

        self.threshold = 1 # threshold for z-score
        self.close_threshold = 0.05 # threshold for exit

        # stocks
        self.symbols = ['AMRI', 'MASI', 'INCR']

        # indicators of long/short position
        self.in_high = False
        self.in_low = False

        # parameters of strategy
        self.m = 15.16673 # mean of spread
        self.sd = 1.605886 # std of spread

        # proportion of stocks for spread
        self.stock_coef = pd.Series([-1, -0.5764114, 0.6813066], index=self.symbols)

        self.prev_zscore = 0 # z-score of previous moment

        self.positions = self._generate_initial_positions

    def _generate_initial_positions(self):
        return pd.Series(np.zeros(len(self.symbols)), index=self.symbols)

    def generate_positions(self, event):

        if event.type == 'MARKET':

            # Getting data
            bars_data = {}

            for symbol in self.symbols:
                bars_data[symbol] = self.datahandler.get_latest_bars(symbol, n=1)

            # Strategy code goes here

            spread = (self.stock_coef.dot()
                self.stock1_coef * bars_data[self.stock1] +
                      self.stock2_coef * bars_data[self.stock2] +
                      self.stock3_coef * bars_data[self.stock3])

            zscore = (spread - self.m) / self.sd

            position = self.positions

            # buy spread
            if not self.in_high and zscore > self.threshold:
                position = pd.Series(np.array([self.stock1_coef, self.stock2_coef, self.stock3_coef]), index=self.symbols)
                self.in_high = True
                self.in_low = False
            # sell spread
            elif not self.in_low and zscore < -self.threshold:
                position = pd.Series(np.array([-self.stock1_coef, -self.stock2_coef, -self.stock3_coef]), index=self.symbols)
                self.in_high = False
                self.in_low = True
            # close long or short position
            elif (((self.in_high  or self.in_low) and np.abs(zscore) < self.close_threshold) or
                  self.prev_zscore * zscore < 0):
                position = pd.Series(np.zeros(len(self.symbol)), index=self.symbols)
                self.in_high = False
                self.in_low = False
            #else - change nothing

            self.prev_zscore = zscore







